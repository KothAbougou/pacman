/* autogenerated by Processing revision 1286 on 2022-12-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.io.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class pacman extends PApplet {




Game game;
KRandom rand;
KTimer timer;
float avant = 0;

File folder;
String[] filenames;

 public void setup() {
  /* size commented out by preprocessor */;
  frameRate(200);

  rand = new KRandom();
  timer = new KTimer(0);

  game = new Game("level2.txt");
  game.users("Richard;Romain;Tom;Maxime;Romane;Ileana;Alice");
}

 public void draw() {
  background(BLACK);

  try
  {
    game.run();
  }
  catch(Exception e){ 
    e.printStackTrace(); 
  }
}

 public void keyPressed() {
  switch(keyCode)
  {
    default:    key = 0;                              break;
    case UP:    game.prepareHeroNextDirection(UP);    break;
    case DOWN:  game.prepareHeroNextDirection(DOWN);  break;
    case LEFT:  game.prepareHeroNextDirection(LEFT);  break;
    case RIGHT: game.prepareHeroNextDirection(RIGHT); break;
    case ESC:
      key = 0;
      if(!game.stateGameIs(StateGame.MENU)){ 
        game.changeStateGameTo(StateGame.MENU);
        frameRate(24); 
      }
    break;
  }
}

 public void mousePressed() {
  if(game.stateGameIs(StateGame.MENU))
    game.onMenuButtonClickEvent();
}

class Board extends KBoard
{
  private Cell[][] _cells;
  private Level    _level;
  private boolean  _alert;
  
  Board(Level level, int cellSize)
  {
    super(level.nbCol, level.nbRow, cellSize);

    _level    = level;
    _alert    = false;

    _initCells();
  }
  
  private void _initCells()
  {
    _cells = new Cell[_nbCol][_nbRow];

    // création des cellules
    for(int col = 0; col < _nbCol; ++col) {
      for(int row = 1; row < _nbRow+1; ++row) {

        TypeCell cell_type = TypeCell.EMPTY;

        switch(_level.getFile()[row].charAt(col))
        {
          case 'x': cell_type = TypeCell.WALL;      break;
          case 'V': cell_type = TypeCell.EMPTY;     break;
          case 'o': cell_type = TypeCell.DOT;       break;
          case 'O': cell_type = TypeCell.SUPER_DOT; break;
          case 'P': cell_type = TypeCell.PACMAN;    break;
          case 'G': cell_type = TypeCell.GHOST;     break;
          case 'T': cell_type = TypeCell.TEST;      break;
        }

        Cell c = new Cell(cell_type, new PVector(col, row-1), _cellSize);
        c.setMargin(_position);

        _cells[col][row-1] = c;
      }
    }

    // vérification des cellules de croisements
    for(int x = 0; x < _nbCol; ++x){
      for(int y = 0; y < _nbRow; ++y){
        Cell c = _cells[x][y];
        c.initAccess(this);
      }
    }
  }

  public Cell getPacmanCell()
  { 
    Cell c = new Cell();
    for(int x = 0; x < _nbCol; ++x)
      for(int y = 0; y < _nbRow; ++y){

        c = _cells[x][y];

        if(c.getType() == TypeCell.PACMAN)
          return c;
      }
    return c;
  }

  public ArrayList<Cell> getGhostsCells()
  {
    ArrayList<Cell> ghostCells = new ArrayList<Cell>();
    Cell c = new Cell();
    for(int x = 0; x < _nbCol; x++){
      for(int y = 0; y < _nbRow; y++){

        c = _cells[x][y];

        if(c.getType() == TypeCell.GHOST)
          ghostCells.add(c);
      }
    }

    return ghostCells;
  }

  public ArrayList<Cell> getSingleAccessCells()
  {
    ArrayList<Cell> singleAccessCells = new ArrayList<Cell>();
    Cell c = new Cell();
    for(int x = 0; x < _nbCol; x++){
      for(int y = 0; y < _nbRow; y++){

        c = _cells[x][y];

        if(c.getType() == TypeCell.GHOST && c.getAccess().size() == 1)
          singleAccessCells.add(c);
      }
    }

    return singleAccessCells;
  }


  public ArrayList<Cell> getCellsAround(Cell cell, int denyAccess)
  {
    ArrayList<Cell> cellsAround = new ArrayList<Cell>();
    ArrayList<Integer> cellAccess = cell.getAccess();
    ArrayList<Integer> allowedAccess = new ArrayList<Integer>();

    int cellX = PApplet.parseInt(cell.getPos("board").x),
        cellY = PApplet.parseInt(cell.getPos("board").y);

    for(Integer access : cellAccess)
      if(access != denyAccess)
        allowedAccess.add(access);

    for(Integer access : allowedAccess)
    {
      Cell c = new Cell();
      switch(access)
      {
        case UP:    c = _cells[cellX][cellY-1]; break;
        case DOWN:  c = _cells[cellX][cellY+1]; break;
        case LEFT:
          if(cellX-1 == -1){ cellX = _nbCol; }  
          c = _cells[cellX-1][cellY]; 
          break;
        case RIGHT: 
          if(cellX+1 == _nbCol-1){ cellY = 0; }  
          c = _cells[cellX+1][cellY]; 
          break;
      }
      cellsAround.add(c);
    }

    return cellsAround;
  }



  public PVector boardPosConversion(PVector screenPos)
  {
    float boardPosX = (screenPos.x - _position.x) / _cellSize;
    float boardPosY = (screenPos.y - _position.y) / _cellSize;

    return new PVector(boardPosX, boardPosY);
  }

  public void setColor(int c)
  {
    if(getColor() != c)
    {
      for(int x = 0; x < _nbCol; ++x)
        for(int y = 0; y < _nbRow; ++y)
        {
          Cell _cell = _cells[x][y];
          if(_cell.getType() == TypeCell.WALL)
            _cell.setColor(c);
        }
    }
  }

  public int getColor()
  {
    return _cells[0][0].getColor();
  }

  public void endScaredModeAlert(KTimer timer)
  {
    setAlert(true);
    float timerMillis = timer.getTime() * 1000;
    float elapsedTime = abs(avant - timerMillis);

    if(elapsedTime >= 200)
    {
      //println(elapsedTime);
      switch(getColor())
      {
        case BLUE: setColor(PURPLE); break;
        case PURPLE: setColor(BLUE); break;
      }

      avant = timerMillis;
    }
  }

  public boolean isAlerting()
  {
    return _alert;
  }

  public void setAlert(boolean b)
  {
    _alert = b;
  }

  public Cell[][] getCells()
  {
    return _cells;
  }
  
  public void drawing(){
    stroke(BLACK);
    strokeWeight(1);
    for(int x = 0; x < _nbCol; ++x)
      for(int y = 0; y < _nbRow; ++y)
        _cells[x][y].drawing();
  }
}
enum BtnEvent
{
	DEFAULT("noValue"), 
	HOME("Retourner au\nmenu principal."),
	USERS("Username?"),
	USER("user button"),
	RESTART("Recommencer\nla partie."), 
	SAVE("Sauvegarder\ncette partie."), 
	SAVES_LEVELS("Liste des parties\nsauvegardées."), 
	HIGHT_SCORE("Meilleurs scores"), 
	LEVEL("level button"),
	EXIT_GAME("Quitter le jeu.");


	private String _value;

	BtnEvent(String value)
	{
		_value = value;
	}

	public String getValue()
	{
		return _value;
	}

}

class Button extends KElement
{
	private BtnEvent _buttonEvent;

	Button(BtnEvent buttonEvent)
	{
		this(buttonEvent, "");
	}

	Button(BtnEvent buttonEvent, String value)
	{
		_buttonEvent = buttonEvent;

		if(!value.equals("")) setKeText(value);
		else setKeText(_buttonEvent.getValue());

		setKeWidth(150);
		setKeHeight(50);
		setKeTextColor(WHITE);
		setKeBackgroundColor(BLACK);
	}

	Button(BtnEvent buttonEvent, String message, PVector pos, float w, float h)
	{
		this(buttonEvent, message);
		setKePosition("screen", pos.x, pos.y);
		setKeWidth(w);
		setKeHeight(h);
		setKeTextSize(PApplet.parseInt(h));
		setKeTextColor(WHITE);
		setKeBackgroundColor(BLACK);
	}

	Button(BtnEvent buttonEvent, String message, PVector pos, float w, float h, int textSize)
	{
		this(buttonEvent, message, pos, w, h);
		setKeTextSize(textSize);
	}

	Button(){ _buttonEvent = BtnEvent.DEFAULT; }

	public void setPosition(PVector pos)
	{
		setKePosition("screen", pos.x, pos.y);
	}

	public boolean isClicked()
	{
		return mouseX >= _ke_screenPos.x && mouseX <= _ke_screenPos.x + _ke_width
			&& mouseY >= _ke_screenPos.y && mouseY <= _ke_screenPos.y + _ke_height;
	}

	public BtnEvent getBtnEvent()
	{
		return _buttonEvent;
	}

	public String getValue()
	{
		return _ke_text;
	}



}
enum TypeCell 
{
  EMPTY("V"), 
  WALL("x"), 
  DOT("o"), 
  SUPER_DOT("O"), 
  PACMAN("P"), 
  GHOST("G"), 
  TEST("T"),
  OUT_BOARD("|");

  private final String _sign;

  TypeCell(String sign)
  {
    _sign = sign;
  }

  public String getSign()
  {
    return _sign;
  }
}

class Cell extends KCell
{
  private TypeCell _type;
  private ArrayList<Integer> _access;


  Cell(TypeCell type, PVector boardPos, int cellSize)
  {
    super(boardPos, cellSize);

    _type      = type;
    _access    = new ArrayList<Integer>();

    _initColor();
    setKeStrokeColor(BLACK);
    setKeStrokeWeight(1);
  }
  Cell()
  { 
    super();
    _type = TypeCell.WALL; 
  }

  private void _initColor()
  {
    switch(_type)
    {
      case WALL: setKeBackgroundColor(BLUE);  break;
      case TEST: setKeBackgroundColor(RED);   break;
        default: setKeBackgroundColor(BLACK); break;
    }
  }

  public void initAccess(Board board)
  {
    Cell[][] cells = board.getCells();
    Cell uCell = new Cell(), 
         lCell = new Cell(), 
         rCell = new Cell(), 
         dCell = new Cell();

    int _x = PApplet.parseInt(_boardPos.x),
        _y = PApplet.parseInt(_boardPos.y);

    if(_type != TypeCell.WALL && _x-1 >= 0 && _x+1 < board.getNbCol() && _y-1 >=0 && _y+1 < board.getNbRow())
    {
      uCell = cells[_x][_y-1];
      lCell = cells[_x-1][_y];
      rCell = cells[_x+1][_y];
      dCell = cells[_x][_y+1];

    }else if(_type != TypeCell.WALL && _x-1 <= -1)
    {
      lCell.setType(TypeCell.OUT_BOARD);
    }else if(_type != TypeCell.WALL && _x+1 >= board.getNbCol())
    {
      rCell.setType(TypeCell.OUT_BOARD);
    }

    if(uCell.getType() != TypeCell.WALL) _access.add(UP);   
    if(rCell.getType() != TypeCell.WALL) _access.add(RIGHT);
    if(dCell.getType() != TypeCell.WALL) _access.add(DOWN); 
    if(lCell.getType() != TypeCell.WALL) _access.add(LEFT); 

    //if(isPivotCell()) _color = PURPLE;
  }

  public boolean isPivotCell()
  {
    return _access.size() > 2;
  }

  public boolean isPivotCell(int threshold)
  {
    return _access.size() >= threshold;
  }

  public ArrayList<Integer> getAccess()
  {
    return _access;
  }

  public void setAccess(int[] directions)
  {
    for(int i = 0; i < _access.size(); i++)
      _access.remove(i);

    for(int i = 0; i < directions.length; i++)
      _access.add(directions[i]);
  }

  public int provideAccess(int denyAccess)
  {
    ArrayList<Integer> allowedAccess = new ArrayList<Integer>();
    for(Integer _a : _access)
      if(_a != denyAccess)
        allowedAccess.add(_a);

    if(allowedAccess.size() > 0){
      return rand.krandom(allowedAccess);
    }else{
      return 0;
    }
  }

  public int provideShortestAccessTo(Hero hero, Board board, int denyAccess)
  {
    ArrayList<Cell> cellsAround = board.getCellsAround(this, denyAccess);
    float[] distCellsHero = new float[cellsAround.size()];

    int i = 0;
    for(Cell cellA : cellsAround)
    {
      PVector cellAPos = cellA.getPos("center");
      float distCH = dist(cellAPos.x, cellAPos.y, hero.getScreenPos().x, hero.getScreenPos().y);

      distCellsHero[i] = distCH;
      i++;
    }

    ArrayList<Integer> allowedAccess = new ArrayList<Integer>();
    for(Integer _a : _access)
      if(_a != denyAccess)
        allowedAccess.add(_a);

    if(distCellsHero.length > 0){
      float minDistCH = min(distCellsHero);
  
      for(int j = 0; j < distCellsHero.length; j++) {
        if(distCellsHero[j] == minDistCH)
          return allowedAccess.get(j);
      }
    }
    return 0;
  }

  public int provideLongestAccessTo(Hero hero, Board board, int denyAccess)
  {
    ArrayList<Cell> cellsAround = board.getCellsAround(this, denyAccess);
    float[] distCellsHero = new float[cellsAround.size()];

    int i = 0;
    for(Cell cellA : cellsAround)
    {
      PVector cellAPos = cellA.getPos("center");
      float distCH = dist(cellAPos.x, cellAPos.y, hero.getScreenPos().x, hero.getScreenPos().y);

      distCellsHero[i] = distCH;
      i++;
    }

    ArrayList<Integer> allowedAccess = new ArrayList<Integer>();
    for(Integer _a : _access)
      if(_a != denyAccess)
        allowedAccess.add(_a);

    if(distCellsHero.length > 0){
      float maxDistCH = max(distCellsHero);
  
      for(int j = 0; j < distCellsHero.length; j++) {
        if(distCellsHero[j] == maxDistCH)
          return allowedAccess.get(j);
      }
    }
    return 0;
  }

  public TypeCell getType()
  {
    return _type;
  }
  public void setType(TypeCell type)
  {
    _type = type;
  }

  public boolean isPointInside(PVector pt)
  {
    boolean isXInside = pt.x >= _screenPos.x && pt.x <= _screenPos.x + _cellSize;
    boolean isYInside = pt.y >= _screenPos.y && pt.y <= _screenPos.y + _cellSize;
    return isXInside && isYInside;
  }

  public boolean isGhostCell(Board board)
  {
    for(Cell ghostCell : board.getGhostsCells())
      if(ghostCell == this)
        return true;
    return false;
  }
}
final int CELL_SIZE = 25; 

final int SCORE_DOT = 10;
final int SCORE_SUPER_DOT = 50;

final int WHITE  = 0xFFFFFFFF,
			BLACK  = 0xFF000000,
			BLUE   = 0xFF0000FF,
			YELLOW = 0xFFFFFF00,
			RED    = 0xFFFF0000,
			PINK   = 0xFFFFC0CB,
			ORANGE = 0xFFFF7F00,
			GREEN  = 0xFF00FF00,
			PURPLE = 0xFF7F00FF;

final PVector PVECTOR_00 = new PVector(0,0);

class Dot
{
	protected PVector _pos;
	protected int 		_size;
	protected int 		_value;
	protected int 	_color;
	protected boolean _active;

	Dot(PVector pos)
	{	
		_pos 		= pos;
		_size 	= 4;
		_value 	= SCORE_DOT;
		_color 	= YELLOW;
		_active = true;
	}

	public void drawing()
	{
		noStroke();
		fill(_color);
		circle(_pos.x, _pos.y, _size);
	}

	public int getValue()
	{
		return _value;
	}

	public boolean isActive()
	{
		return _active;
	}

	public void setActive(boolean b)
	{
		_active = b;
	}

	public boolean isEatenBy(Hero hero)
	{
		PVector heroPos = hero.getScreenPos();

		boolean isEaten = false;
		switch(hero.getDirection("current"))
		{
			case UP:    isEaten = _pos.x == heroPos.x && dist(0, _pos.y, 0, heroPos.y) < CELL_SIZE/2.5f; break;
			case DOWN:  isEaten = _pos.x == heroPos.x && dist(0, _pos.y, 0, heroPos.y) < CELL_SIZE/2.5f; break;
			case LEFT:  isEaten = _pos.y == heroPos.y && dist(_pos.x, 0, heroPos.x, 0) < CELL_SIZE/2.5f; break;
			case RIGHT: isEaten = _pos.y == heroPos.y && dist(_pos.x, 0, heroPos.x, 0) < CELL_SIZE/2.5f; break;
		}

		return isEaten;
	}
}

class SuperDot extends Dot
{
	SuperDot(PVector pos)
	{
		super(pos);
		_size  = _size * 3;
		_value = SCORE_SUPER_DOT;
	}

}
enum StateGame
{
  PLAY, MENU;
}

enum MoodGame
{
  DEFAULT(0), SCARED(0);

  private int _nbGhostKilled;
  public final float SCARED_PERIOD;

  MoodGame(int nb)
  {
    _nbGhostKilled = nb;
    SCARED_PERIOD = 15; // 15 secondes
  }

  public void otherGhostKilled()
  {
    _nbGhostKilled ++;
  }

  public int getNbGhostKilled()
  {
    return _nbGhostKilled;
  }
}
class Game 
{
  private Levels    _levels;
  private Level     _level;
  private StateGame _state;
  private Menu      _menu;
  private String[]  _users;
  private String    _user; 
  private String    _notif;     
  private Scores    _scores;  

  private MoodGame _mood;
  private Board    _board;
  private Hero     _hero;
  private ArrayList<Ghost> _ghosts;
  private ArrayList<Dot>   _dots;
  
  
  Game(String levelName) {
    _user = "";
    _notif = "";
    _scores = new Scores();
    _levels = new Levels();
    _level  = _levels.getLevel(levelName);
    _board  = new Board(_level, CELL_SIZE);
    _menu   = new Menu(this);

    println("pacmanByKoth >> Ouverture du jeu.");

    _startGame();

  }

  public void run()
  {
    _updates();
    _views();
  }
  
  private void _updates() 
  {
    switch(_state)
    {
      case PLAY:
        _updateGame();
        _updateBoard();
        _updateDots();
        _updateHero();
        _updateGhosts();
        break;
    }
  }
  private void _views() 
  {
    switch(_state)
    { 
      case PLAY:
        _sidebarsView();
        _boardView();
        _dotsView();
        _heroView();
        _ghostsView();
        break;

      case MENU:
        _menuView();
        break;
    }
  }

  ////////////////////////////
  //         GAME           //
  ////////////////////////////
  
  private void _updateGame()
  {
    _updateGameWin();
    _updateGameMood();
  }

  private void _updateGameWin()
  {
    int nbDotActive = 0;

    for(Dot _dot : _dots)
      if(_dot.isActive())
        nbDotActive ++;

    if(nbDotActive == 0)
    {
      _notif ="Victoire avec" + _hero.getScore() + " points!";
      _menu.changePage(PageMenu.HOME);
      changeStateGameTo(StateGame.MENU);

      if(_user.equals("")) println("pacmanByKoth >>", _notif);
      else println("pacmanByKoth >>", _notif, "de", _user);

      if(!_user.equals(""))
       _scores.addScore(";"+_user+"|V|"+_hero.getScore());

    }
  }
  public boolean stateGameIs(StateGame state)
  {
    return _state == state;
  }
  public void changeStateGameTo(StateGame state)
  {
    _state = state;
  }

  private void _updateGameMood()
  {
    if(_mood == MoodGame.SCARED && timer.getTime() <= _mood.SCARED_PERIOD)
    {
      timer.countUp();

      if(timer.getTime() >= _mood.SCARED_PERIOD - 2)
        _board.endScaredModeAlert(timer);
    }else{
      _mood = MoodGame.DEFAULT;
      _board.setAlert(false);
      timer.setTime(0);
    }
  }

  private void _startGame()
  {
    changeStateGameTo(StateGame.PLAY);
    _mood   = MoodGame.DEFAULT;
    _hero   = new Hero(_board);
    _ghosts = _initGhosts();
    _dots   = _initDots();

    if(_user.equals(""))
      println("pacmanByKoth >> Lancement du level --", _level.getName(),"--");
    else 
      println("pacmanByKoth >> Lancement du level --", _level.getName(), "-- avec", _user);
  }

  public void changeLevelGame(String levelName)
  {
    _level = _levels.getLevel(levelName);
    _board  = new Board(_level, CELL_SIZE);
  }

  private void _resetGame()
  {
    _mood = MoodGame.DEFAULT;
    _resetHero();
    _resetGhosts();
  }

  private void _endGame()
  {
    _notif = "Défaite avec " + _hero.getScore() + " points.";
    _menu.changePage(PageMenu.HOME);
    changeStateGameTo(StateGame.MENU);

    if(_user.equals("")) println("pacmanByKoth >>", _notif);
    else println("pacmanByKoth >>", _notif, "de", _user);

    if(!_user.equals(""))
      _scores.addScore(";"+_user+"|D|"+_hero.getScore());

  }

  private void _exitGame()
  {
    println("pacmanByKoth >> Vous avez quitté le jeu.");
    exit();
  }

  public void users(String users)
  {
    _users = split(users, ";");
  }

  public void selectUser(String user)
  {
    _user = user;
  }

  public String getUser()
  {
    return _user;
  }

  public String[] getUsers()
  {
    return _users;
  }

  public String getNotif()
  {
    return _notif;
  }

  public Scores getScores()
  {
    return _scores;
  }

  ////////////////////////////
  //         Menu           //
  ////////////////////////////
  
  private void _menuView()
  {
    _menu.drawing();
  }

  public void onMenuButtonClickEvent()
  {
    switch(_menu.getBtnEventOnClick())
    {
      case EXIT_GAME:     _exitGame();                              break;
      case RESTART:       _startGame(); frameRate(200);             break;
      case LEVEL:         _startGame(); frameRate(200);             break;
      case HOME:          _menu.changePage(PageMenu.HOME);          break;
      case USERS:         _menu.changePage(PageMenu.CHANGE_USERS);  break;
      case USER:          _menu.changePage(PageMenu.HOME);          break;
      case SAVES_LEVELS:  _menu.changePage(PageMenu.SAVES_LEVELS);  break;
      case HIGHT_SCORE:   _menu.changePage(PageMenu.BEST_SCORES);   break;
    }
  }

  ////////////////////////////
  //         SIDEBAR        //
  ////////////////////////////
  
  private void _sidebarsView()
  {
    _topbarView();
    _bottombarView();
  }

  private void _topbarView()
  {
    fill(WHITE);
    textSize(28);
    text("HIGHT SCORE: "+ _hero.getScore(), width/4, 50);
  }

  private void _bottombarView()
  {
    fill(WHITE);
    textSize(28);
    text("VIES: "+ _hero.getLives(), width/4, height - 50);
  }

  ////////////////////////////
  //         BOARD          //
  ////////////////////////////
  private void _boardView()
  {
    _board.drawing();
  }

  private void _updateBoard()
  {
    _updateBoardByGameMood();
  }

  private void _updateBoardByGameMood()
  {
    switch(_mood)
    {
      case SCARED: 
        if(!_board.isAlerting()) _board.setColor(PURPLE); 
        break;

      default: _board.setColor(BLUE);  break;
    }
  }

  ////////////////////////////
  //         DOTS           //
  ////////////////////////////
  
  private ArrayList<Dot> _initDots()
  {
    ArrayList<Dot> dots = new ArrayList<Dot>();
    Cell[][] cells = _board.getCells();

    for(int x = 0; x < _board.getNbCol(); x++)
      for(int y = 0; y < _board.getNbRow(); y++)
      {
        Cell c = cells[x][y];

        if(c.getType() == TypeCell.DOT || c.getType() == TypeCell.SUPER_DOT)
        {
          Dot dot = new Dot(new PVector(0,0));
          switch(c.getType())
          {
            case DOT: dot = new Dot(c.getPos("center")); break;
            case SUPER_DOT: dot = new SuperDot(c.getPos("center")); break;
          }

          dots.add(dot);
        }

      }
      
    return dots;
  }
  
  private void _dotsView()
  {
    for(Dot _dot : _dots)
      if(_dot.isActive())
        _dot.drawing();
  }

  private void _updateDots()
  {
    _updateDotsWhenEatenByHero();
  }

  private void _updateDotsWhenEatenByHero()
  {
    for(Dot _dot : _dots)
      if(_dot.isActive() && _dot.isEatenBy(_hero))
      {
        if(_dot instanceof SuperDot)
          _mood = MoodGame.SCARED;

        _hero.addScore(_dot.getValue());
        _dot.setActive(false);
      }
  }

  ////////////////////////////
  //         HERO           //
  ////////////////////////////
  
  private void _heroView()
  {
    _hero.drawing();
  }

  public void prepareHeroNextDirection(int direction) 
  {
    _hero.setDirection("next", direction);
  }

  private void _updateHero()
  {
    _updateHeroMovement();
  }

  private void _updateHeroMovement()
  {
    int currentDirection = _hero.getDirection("current"),
        nextDirection    = _hero.getDirection("next");
    
    if(_hero.isMoveableTo("nextDirection") && nextDirection != currentDirection)
      _hero.setDirection("current", nextDirection);

    else if(_hero.isMoveableTo("currentDirection"))
      _hero.move(currentDirection);
  }

  private void _resetHero()
  {
    _hero.putOnStartingCell();
  }

  ////////////////////////////
  //         GHOSTS         //
  ////////////////////////////
  
  private ArrayList<Ghost> _initGhosts()
  {
    ArrayList<Ghost> ghosts = new ArrayList<Ghost>();
    ArrayList<Cell> ghostsCells = _board.getGhostsCells();

    for(int i=0; i < ghostsCells.size(); i++)
    {
      Ghost g = new Ghost(TypeGhost.generate(PApplet.parseInt(random(1,5))), _board);
      g.putOnCell(ghostsCells.get(i));
      ghosts.add(g);
    }

    return ghosts;
  }

  private void _ghostsView()
  {
    for(Ghost _g : _ghosts)
      _g.drawing();
  }

  private void _updateGhosts()
  {
    _updateGhostsDirections();
    _updateGhostsMoveModes();
    _updateGhostsMovements();
    _updateGhostsCollisions();
  }

  private void _updateGhostsCollisions()
  {
    for(Ghost _g : _ghosts)
      if(_g.isInCollisionWith(_hero))
      {
        switch(_mood)
        {
          case SCARED:
            Cell boardGhostCell = _board.getGhostsCells().get(0);
            PVector bgCellPos = boardGhostCell.getPos("center");

            _g.setScreenPos(bgCellPos.x, bgCellPos.y);
            _g.setDirection("next", RIGHT);

            _mood.otherGhostKilled();
            int value = PApplet.parseInt(200 * pow(2, _mood.getNbGhostKilled() -1));
            _hero.addScore(value);

            break;
          default:
            _hero.losesOneLife();
            if(_hero.getLives() > 0)
              _resetGame();
            else
              _endGame();
            break;
        }
      }
  }
  private void _updateGhostsDirections()
  {
    Cell firstSACell = _board.getSingleAccessCells().get(0),
         lastSACell  = _board.getSingleAccessCells().get(1);

    for(Ghost _g : _ghosts)
    {
      Cell ghostCell = _g.getCell();
      int currentDirection = _g.getDirection("current");

      if(ghostCell == firstSACell && currentDirection == LEFT && _g.isMoving("onCellCenter"))
        _g.setDirection("next", RIGHT);
      else if(ghostCell == lastSACell && currentDirection == RIGHT &&  _g.isMoving("onCellCenter"))
        _g.setDirection("next", LEFT);
      else
        _g.generateNextDirection(_hero);
    }
  }
  private void _updateGhostsMoveModes()
  {
    for(Ghost _g : _ghosts)
    {
      switch(_mood)
      {
        default:
          if(_g.isInsideHeroZone(_hero))
            _g.setMoveMode(GhostMoveMode.HUNTING);
          else
            _g.setMoveMode(GhostMoveMode.DISPERSAL);

          if(_ghosts.get(_ghosts.size()-1).getColor() == BLUE)
            _g.setColor(_g.getType().getColor());
          break;

        case SCARED:
          if(_g.isInsideHeroZone(_hero))
            _g.setMoveMode(GhostMoveMode.SCARED);
          else
            _g.setMoveMode(GhostMoveMode.DISPERSAL);

          //if(_ghosts.get(_ghosts.size()-1).getColor() != BLUE)
            _g.setColor(BLUE);
          break;
      }
    }
  }
  private void _updateGhostsMovements()
  {
    for(Ghost _g : _ghosts)
    {
      int currentDirection = _g.getDirection("current"),
          nextDirection    = _g.getDirection("next");

      if(_g.isMoveableTo("nextDirection") && nextDirection != currentDirection)
        _g.setDirection("current", nextDirection);

      else if(_g.isMoveableTo("currentDirection"))
        _g.move(currentDirection);
    }
  }

  private void _resetGhosts()
  {
    ArrayList<Cell> ghostsCells = _board.getGhostsCells();

    int i = 0;
    for(Ghost _g : _ghosts)
    {
      _g.putOnCell(ghostsCells.get(i));
      i++;
    }
  }

}
enum TypeGhost
{
	RED(0xFFFF0000), 
	PINK(0xFFFFC0CB), 
	ORANGE(0xFFFF7F00), 
	GREEN(0xFF00FF00), 
	PURPLE(0xFF7F00FF);

	private final int _color;

	TypeGhost(int c)
	{
		_color = c;
	}

	public int getColor()
	{
		return _color;
	}

	public static TypeGhost generate(int id)
	{
		TypeGhost type;
		switch(id)
		{
			case 1: type = TypeGhost.RED; 		break;
			case 2: type = TypeGhost.PINK; 		break;
			case 3: type = TypeGhost.ORANGE; 	break;
			case 4: type = TypeGhost.GREEN; 	break;
			case 5: type = TypeGhost.PURPLE; 	break;
			default: type = TypeGhost.RED; 		break;
		}

		return type;
	}
}
enum GhostMoveMode
{
	HUNTING(1), DISPERSAL(1), SCARED(0.5f);

	private final float _speed;

	GhostMoveMode(float speed)
	{
		_speed = speed;
	}

	public float getSpeed()
	{
		return _speed;
	}
}
class Ghost extends Pawn
{
	private TypeGhost 		_type;
	private GhostMoveMode _moveMode;
	private float 				_speed;
	private int 				_color;
	private boolean       _alive;

	Ghost(TypeGhost type, Board board)
	{
		super(board);
		_type  		     = type;
		_moveMode      = GhostMoveMode.DISPERSAL;
		_speed 		     = _moveMode.getSpeed();
		_color 				 = _type.getColor();
		_alive				 = false;
	}

	public void putOnCell(Cell cell)
	{
		_cell = cell;
		_screenPos = new PVector(_cell.getPos("center").x, _cell.getPos("center").y);
	  _boardPos  = new PVector(_cell.getPos("board").x, _cell.getPos("board").y);

	  _nextCellAssociation(_direction);
	}

	public void generateNextDirection(Hero hero)
	{
		int nextDirection = 0;

		switch(_moveMode)
		{
			case HUNTING: nextDirection = _cell.provideShortestAccessTo(hero, _board, reverseDirection()); break;
			case  SCARED: nextDirection = _cell.provideLongestAccessTo(hero, _board, 0); break;

			default:
				PVector _nextCellPos = _nextCell.getPos("center");
				float distGhostNextCell = dist(_screenPos.x, _screenPos.y, _nextCellPos.x, _nextCellPos.y);

				if(distGhostNextCell < _board.getCellSize())
					nextDirection = _nextCell.provideAccess(reverseDirection());
				break;
		}

		switch(nextDirection)
		{
			case 0: _nextDirection = _nextDirection; break;
			default: _nextDirection = nextDirection; break;
		}
	}

  public PVector getLastBoardPos()
  {
  	return _lastBoardPos;
  }

  public boolean isInCollisionWith(Hero hero)
  {
  	return _cell == hero.getCell();
  }

  public boolean isInsideHeroZone(Hero hero)
  {
  	PVector hPos = hero.getScreenPos();
		float distGhostHero = dist(_screenPos.x, _screenPos.y, hPos.x, hPos.y);

    return distGhostHero < hero.getZone()
    			 && _cell.isPivotCell()
           && _cell.getType() != TypeCell.EMPTY
           && _cell.getType() != TypeCell.GHOST;
  }

  public void setMoveMode(GhostMoveMode moveMode)
  {
  	_moveMode = moveMode;
  	_speed = _moveMode.getSpeed();
  	//println("speed:",_speed);

  	switch(_moveMode)
  	{
  		case SCARED: _color = BLUE;  						break;
  		    default: _color = _type.getColor(); break;
  	}
  }

  public void setColor(int c)
  {
  	_color = c;
  }

  public int getColor()
  {
  	return _color;
  }

  public TypeGhost getType()
  {
  	return _type;
  }

  public void move(int direction)
  {
  	super.move(direction);

  	if(isMoving("onScreen") && _cell.isGhostCell(_board))
  		_alive = false;
  	else
  		_alive = true;

  }

  public boolean isAlive()
  {
  	return _alive;
  }

  public void setAlive(boolean b)
  {
  	_alive = b;
  }

  public void drawing()
  {
  	noStroke();
  	fill(_color);
  	circle(_screenPos.x, _screenPos.y, _board.getCellSize()+10);
  }
}
class Hero extends Pawn
{
  private int _lives;
  private int _score;

  Hero(Board board)
  {
    super(board);

    putOnStartingCell();

    _lives = 2;
    _score = 0;
  }

  public void putOnStartingCell()
  {
    _cell          = _board.getPacmanCell();
    _screenPos     = new PVector(_cell.getPos("center").x, _cell.getPos("center").y);
    _boardPos      = new PVector(_cell.getPos("board").x, _cell.getPos("board").y); 
    _direction     = LEFT;

    _nextCellAssociation(_direction);
  }

  public void addScore(int value)
  {
    _score += value;
  }

  public int getScore()
  {
    return _score;
  }

  public float getZone()
  {
    return _board.getCellSize() * _board.getNbCol() / 3;
  }

  public int getLives()
  {
    return _lives;
  }

  public void losesOneLife()
  {
    _lives --;
  }

  public void drawing()
  {
    noStroke();
    fill(YELLOW);
    circle(_screenPos.x, _screenPos.y, CELL_SIZE);
  }
}
class KBoard
{
	private KElement[][] _containers;
  protected PVector  _position;
  protected int      _nbCol;
  protected int      _nbRow;
  protected int      _cellSize;

	KBoard(int nbCol, int nbRow, int cellSize)
	{
		_nbCol    = nbCol;
    _nbRow    = nbRow;
    _cellSize = cellSize;

    _initPosition();

    if(getClass().getSimpleName().equals("KBoard"))
   		_initContainers();
	}

	private void _initContainers()
	{
		_containers = new KElement[_nbCol][_nbCol];

		for(int x = 0; x < _nbCol; x++)
			for(int y = 0; y < _nbRow; y++)
			{
				KCell container = new KCell(new PVector(x, y), _cellSize);
				container.setKeBackgroundColor(BLACK);
				container.setKePosition("offset", _position.x, _position.y);
				_containers[x][y] = container;
			}
	}

	private void _initPosition()
  {
    float boardW = _nbCol * _cellSize,
          boardH = _nbRow * _cellSize,
          boardMgX = (width - boardW)/2,
          boardMgY = (height - boardH)/2;

    _position = new PVector(boardMgX, boardMgY);
  }

  public void setOffset(float x, float y)
  {
  	_position.x += x;
  	_position.y += y;

  	if(getClass().getSimpleName().equals("KBoard"))
   		_initContainers();
  }

  public int getNbRow()
  {
    return _nbRow;
  }

  public int getNbCol()
  {
    return _nbCol;
  }

  public int getCellSize()
  {
    return _cellSize;
  }

  public KElement[][] getCells()
  {
    return _containers;
  }

  public ArrayList<KElement> getCellsList()
  {
  	ArrayList<KElement> cellsList = new ArrayList<KElement>();

  	for(int x = 0; x < _nbCol; x++)
  		for(int y = 0; y < _nbRow; y++)
  		{
  			cellsList.add(_containers[x][y]);
  		}

  	return cellsList;
  }
}
class KCell extends KElement
{
	protected PVector  _boardPos, _margin, _screenPos, _centerPos;
  protected int    _color;
  protected int      _cellSize;

  KCell(PVector boardPos, int cellSize)
  {
    _boardPos  = boardPos;
    _margin    = PVECTOR_00;
    _screenPos = _ke_screenPos;
    _centerPos = _ke_centerPos;
    _cellSize  = cellSize;

    setKeWidth(_cellSize);
    setKeHeight(_cellSize);
    setKeStrokeColor(BLACK);
    setKeStrokeWeight(3);

    _updateScreenPos();
    _updateCellCenterPos();
  }

  KCell(){}

  protected void _updateScreenPos()
  {
    float screenPosX = _boardPos.x * _cellSize + _margin.x,
          screenPosY = _boardPos.y * _cellSize + _margin.y;

    _screenPos.x = screenPosX;
    _screenPos.y = screenPosY;
  }

  protected void _updateCellCenterPos()
  {
    float centerPosX = _screenPos.x + _cellSize/2,
          centerPosY = _screenPos.y + _cellSize/2;

    _centerPos.x = centerPosX;
    _centerPos.y = centerPosY;
  }

  public PVector getPos(String from)
  {
    PVector pos;
    switch(from)
    {
      case "board":  pos = _boardPos;  break;
      case "center": pos = _centerPos; break;
      case "screen": pos = _screenPos; break;
      default:       pos = _boardPos;  break;
    }

    return pos;
  }

  public void setColor(int c)
  {
    _color = c;
    setKeBackgroundColor(_color);
  }

  public int getColor()
  {
    return _color;
  }

  public void setMargin(PVector margin)
  {
    _margin = margin;

    _updateScreenPos();
    _updateCellCenterPos();
    //setKePosition("offset", margin.x, margin.y);
  }

  //public void drawing()
  //{
  //  fill(_color);
  //  rect(_screenPos.x, _screenPos.y, _cellSize, _cellSize);
  //}
}
class KElement
{
	protected KElement _ke_parent;
	protected ArrayList<KElement> _ke_children = new ArrayList<KElement>();

	protected PVector 	_ke_screenPos 		= new PVector(0,0);
	protected PVector 	_ke_centerPos			= new PVector(0,0);
	protected PVector 	_ke_offset        = new PVector(0,0);
	protected float 		_ke_width 				= 0;
	protected float 		_ke_height				= 0;

	protected int 			_ke_strokeWeight  = 0;
	protected int  		_ke_strokeColor   = 0xFF000000;
	protected int 		_ke_bgColor       = 0xFFFFFFFF;
	protected int 			_ke_textAlignX		= CENTER;
	protected int  			_ke_textAlignY 		= CENTER;

	//protected boolean 	_ke_border				= true;
	//protected int 			_ke_borderWeight  = 2;
	//protected color    	_ke_borderColor		= #000000;
	//protected float     _ke_borderOffset  = -5;

	protected String 		_ke_text          = "";
	protected int 			_ke_textSize      = 16;
	protected int   	_ke_textColor     = 0xFF000000;


	KElement()
	{
		_updateKeCenterPos();
	}

	public void drawing()
	{
		float x = _ke_screenPos.x,
					y = _ke_screenPos.y;

		stroke(_ke_strokeColor);
		strokeWeight(_ke_strokeWeight);

		fill(_ke_bgColor);
		rect(x, y, _ke_width, _ke_height);

		if(!_ke_text.equals(""))
		{
			fill(_ke_textColor);
			textSize(_ke_textSize);
			textAlign(_ke_textAlignX, _ke_textAlignY);
			text(_ke_text, _ke_centerPos.x, _ke_centerPos.y);
		}

		if(_ke_children.size() > 0)
			for(KElement kec : _ke_children)
				kec.drawing();

	}

	protected void _updateKeCenterPos()
  {
    float centerPosX = _ke_screenPos.x + _ke_width/2,
          centerPosY = _ke_screenPos.y + _ke_height/2;

    _ke_centerPos = new PVector(centerPosX, centerPosY);
  }

  public int getKeStrokeWeight()
  {
  	return _ke_strokeWeight;
  }
  public void setKeStrokeWeight(int keStrokeWeight)
  {
  	_ke_strokeWeight = keStrokeWeight;
  }

  public int getKeStrokeColor()
  {
  	return _ke_strokeColor;
  }
  public void setKeStrokeColor(int keStrokeColor)
  {
  	_ke_strokeColor = keStrokeColor;
  }

  public int getKeBackgroundColor()
  {
  	return _ke_bgColor;
  }
  public void setKeBackgroundColor(int keBgColor)
  {
  	_ke_bgColor = keBgColor;
  }

  public String getKeText()
  {
  	return _ke_text;
  }
  public void setKeText(String keText)
  {
  	_ke_text = keText;
  }

  public int getKeTextSize()
  {
  	return _ke_textSize;
  }
  public void setKeTextSize(int keTextSize)
  {
  	_ke_textSize = keTextSize;
  }

  public int getKeTextColor()
  {
  	return _ke_textColor;
  }
  public void setKeTextColor(int keTextColor)
  {
  	_ke_textColor = keTextColor;
  }

  public void setKeTextAlign(int keTextAlignX, int keTextAlignY)
  {
  	_ke_textAlignX = keTextAlignX;
  	_ke_textAlignY = keTextAlignY;
  }

  public float getKeWidth()
  {
  	return _ke_width;
  }
  public void setKeWidth(float keWidth)
  {
  	_ke_width = keWidth;
  	_updateKeCenterPos();
  }

  public float getKeHeight()
  {
  	return _ke_height;
  }
  public void setKeHeight(float keHeight)
  {
  	_ke_height = keHeight;
  	_updateKeCenterPos();
  }

  public PVector getKePosition(String from)
  {
    PVector pos;
    switch(from)
    {
      case "screen": pos = _ke_screenPos; break;
      case "center": pos = _ke_centerPos; break;
      default: pos = _ke_screenPos; break;
    }

    return pos;
  }
  public void setKePosition(String about, float x, float y)
  {
  	switch(about)
  	{
  		case "screen": 
  			_ke_screenPos.x = x; 
  			_ke_screenPos.y = y; 
  		break;
  		case "offset":
  			_ke_screenPos.x += x; _ke_offset.x += x;
  			_ke_screenPos.y += y; _ke_offset.y += y;
  		break;
  		default: setKePosition("screen", x, y); break;
  	}

  	_updateKeCenterPos();
  }

	public KElement getParent()
	{
		return _ke_parent;
	}

	public void removeParent(KElement keParent)
	{
		_ke_parent = null;
		keParent.removeChild(this);
	}

	private void _putParent(KElement keParent)
	{
		_ke_parent = keParent;
		keParent.getChildren().add(this);
	}

	public ArrayList<KElement> getChildren()
	{
		return _ke_children;
	}

	public void addChild(KElement keChild, String option)
	{
		if(keChild.getParent() == null)
		{ 
			keChild._putParent(this);

			switch(option)
			{
				default:
					keChild.setKePosition("screen", _ke_screenPos.x, _ke_screenPos.y);
					keChild.setKeWidth(_ke_width);
					keChild.setKeHeight(_ke_height);
					keChild.setKeStrokeWeight(_ke_strokeWeight);
					keChild.setKeStrokeColor(_ke_strokeColor);
					keChild.setKeTextSize(_ke_textSize);
					keChild.setKeTextColor(_ke_textColor);
					keChild.setKeTextAlign(_ke_textAlignX, _ke_textAlignY);
					break;

				case "noStyleInherit": break;
			}
		}
	}

	public void addChild(KElement keChild)
	{
		addChild(keChild, "");
	}

	public void removeChild(KElement keChild)
	{
		ArrayList<KElement> keChildren = new ArrayList<KElement>();

		for(KElement kec : _ke_children)
			if(kec != keChild)
				keChildren.add(kec);

		_ke_children = keChildren;
	}
	public void removeChild(int iKeChild)
	{
		ArrayList<KElement> keChildren = new ArrayList<KElement>();

		int i=0;
		for(KElement kec : _ke_children)
		{
			if(i != iKeChild)
				keChildren.add(kec);
			i++;
		}

		_ke_children = keChildren;

	}

	public void removeAllChildren()
	{
		for(KElement kec : _ke_children)
			if(_ke_children.size() > 0)
				kec.removeParent(this);
	}
}
class KRandom
{
	private float _rand;

	KRandom(){}

	private void _generateRand()
	{
		_rand = random(0, 100);
	}

	private float _cut(int in)
	{
		return 100 / in;
	}

	public int krandom(ArrayList<Integer> list)
	{
		_generateRand();
		float piece = _cut(list.size());

		ArrayList<Float> pieces = new ArrayList<Float>();
		for(int i=1; i <= list.size(); i++)
			pieces.add(piece*i);

		for(int i=0; i < pieces.size(); i++)
			if(_rand <= pieces.get(i))
				return list.get(i);

		return list.get(0);
	}

	public int krandom(int[] list)
	{
		_generateRand();
		float piece = _cut(list.length);

		ArrayList<Float> pieces = new ArrayList<Float>();
		for(int i=1; i <= list.length; i++)
			pieces.add(piece*i);

		for(int i=0; i < pieces.size(); i++)
			if(_rand <= pieces.get(i))
				return list[i];
			
		return list[0];
	}


}
/**
 * {@link https://www.youtube.com/watch?v=c8sc_w-g3-A }
 */
class KTimer
{
	private float _time;

	KTimer(float t)
	{
		_time = t;
	}

	public float getTime()
	{
		return _time;
	}

	public void setTime(float t)
	{
		_time = t;
	}

	public void countUp()
	{
		_time += 1 / frameRate;
	}

	public void countDown()
	{
		_time -= 1 / frameRate;
	}
}
class Level
{
	private String 	 _fileName;
	private String[] _fileStr;
	public  String 	 title;
	public  int      nbCol, nbRow;


	Level(String levelName)
	{
		_fileName = levelName;
		_fileStr  = loadStrings("data/levels/"+_fileName);

		title = _fileStr[0];
		nbCol = _fileStr[1].length();
		nbRow = _fileStr.length-1; 
	}

	public String[] getFile()
	{
		return _fileStr;
	}

	public String getName()
	{
		return _fileName;
	}
}

class Levels
{

	private ArrayList<Level> _levels;

	Levels()
	{
		_loadLevels();
	}

	private void _loadLevels()
	{
		_levels = new ArrayList<Level>();

		File levelsDir = new File(dataPath("/levels"));
		File[] levelsFiles = levelsDir.listFiles();

		for(File levelFile : levelsFiles)
		{
			if(levelFile.isFile())
			{
				String levelName = levelFile.getName();
				Level level = new Level(levelName);
				_levels.add(level);
			}
		}
	}

	public Level getLevel(String levelName)
	{
		Level l = new Level("level1.txt");

		for(Level level : _levels)
			if(level.getName().equals(levelName))
				l = level;

		return l;
	}

	public ArrayList<Level> getAllLevels()
	{
		return _levels;
	}
}
enum PageMenu
{
  HOME, BEST_SCORES, SAVES_LEVELS, CHANGE_USERS;
}

class Menu
{
  private Game                _game;
  private PageMenu            _page;
  private KBoard              _template;
  private ArrayList<KElement> _elements;
  private Levels              _levels;
  private Scores              _scores;

  Menu(Game game)
  {
    _game     = game;
    _scores   = _game.getScores();
    _levels   = new Levels();
    _page     = PageMenu.HOME;
    _template = new KBoard(2,2,287);
    _template.setOffset(0, 50);

    _loadElementsIntoPage();
  }

  private void _loadElementsIntoPage()
  {
    ArrayList<KElement> containers = _template.getCellsList();
    ArrayList<KElement> elements = new ArrayList<KElement>();
    KElement ke = new KElement();

    switch(_page)
    {
      case HOME:
        ke = new Button(BtnEvent.RESTART);      elements.add(ke);
        ke = new Button(BtnEvent.SAVE);         elements.add(ke);
        ke = new Button(BtnEvent.SAVES_LEVELS); elements.add(ke);
        ke = new Button(BtnEvent.HIGHT_SCORE);  elements.add(ke);
        ke = new Button(BtnEvent.EXIT_GAME);    elements.add(ke);
        ke = new Button(BtnEvent.USERS);        elements.add(ke);
        ke = new KElement();                    elements.add(ke);

        _elements = elements;

        int i=0;
        for(KElement container : containers)
        {
          Button button = (Button) _elements.get(i);
          container.addChild(button);
          button.setKeTextColor(PURPLE);
          button.setKeBackgroundColor(YELLOW);
          button.setKeTextSize(28);

          if(container == containers.get(0))
          {
            PVector cPos = container.getKePosition("screen");

            KElement notifBar = _elements.get(6);
            container.addChild(notifBar);
            notifBar.setKeTextColor(WHITE);
            notifBar.setKeBackgroundColor(BLACK);
            notifBar.setKeHeight(50);
            notifBar.setKeWidth(2 * container.getKeWidth());
            notifBar.setKePosition("screen", cPos.x, cPos.y - 2.5f * notifBar.getKeHeight());
            notifBar.setKeTextSize(28);
            if(!_game.getNotif().equals("")) notifBar.setKeText(_game.getNotif());

            Button buttonUsers = (Button) _elements.get(5);
            container.addChild(buttonUsers);
            buttonUsers.setKeTextColor(WHITE);
            buttonUsers.setKeBackgroundColor(BLUE);
            buttonUsers.setKeTextSize(28);
            buttonUsers.setKeHeight(50);
            buttonUsers.setKePosition("screen", cPos.x, cPos.y - buttonUsers.getKeHeight());
            if(!_game.getUser().equals("")) buttonUsers.setKeText(_game.getUser());
          }

          if(container == containers.get(2))
          {
            PVector cPos = container.getKePosition("screen");

            Button buttonExit = (Button) _elements.get(4);
            container.addChild(buttonExit);
            buttonExit.setKeTextColor(WHITE);
            buttonExit.setKeBackgroundColor(RED);
            buttonExit.setKeTextSize(28);
            buttonExit.setKeHeight(50);
            buttonExit.setKePosition("screen", cPos.x, cPos.y - buttonExit.getKeHeight());
          }

          i++;
        }

        break;

      case SAVES_LEVELS:
        ke = new Button(BtnEvent.HOME); elements.add(ke);
        ke = new KElement();            elements.add(ke);

        _elements = elements;

        for(KElement container : containers)
        {
          if(container == containers.get(0))
          {
            Button buttonMenu = (Button) _elements.get(0);
            container.addChild(buttonMenu);
            buttonMenu.setKeTextColor(PURPLE);
            buttonMenu.setKeBackgroundColor(YELLOW);
            buttonMenu.setKeTextSize(28);
          }

          if(container == containers.get(3))
          {
            PVector container2Pos = containers.get(2).getKePosition("screen");

            KElement levelsBar = _elements.get(1);
            container.addChild(levelsBar);
            levelsBar.setKePosition("screen", container2Pos.x, container2Pos.y);
            levelsBar.setKeTextColor(PURPLE);
            levelsBar.setKeBackgroundColor(YELLOW);
            levelsBar.setKeHeight(2 * container.getKeHeight());


            ArrayList<KElement> levelButtons = new ArrayList<KElement>();

            for(Level level : _levels.getAllLevels()){
              ke = new Button(BtnEvent.LEVEL, level.getName()); 
              levelButtons.add(ke); 
              elements.add(ke);
            }
            
            int j = 0;
            for(KElement lvButton : levelButtons)
            {
              Button b = (Button) lvButton;
              levelsBar.addChild(b);
              b.setKeBackgroundColor(PURPLE);
              b.setKeTextColor(WHITE);
              b.setKeTextSize(28);
              b.setKeHeight(35);
              b.setKePosition("screen", levelsBar.getKePosition("screen").x , levelsBar.getKePosition("screen").y+j*b.getKeHeight());
              j++;
            }

          }
        }

        break;

        case CHANGE_USERS:
        ke = new Button(BtnEvent.HOME); elements.add(ke);
        ke = new KElement();            elements.add(ke);

        _elements = elements;

        for(KElement container : containers)
        {
          if(container == containers.get(0))
          {
            Button buttonMenu = (Button) _elements.get(0);
            container.addChild(buttonMenu);
            buttonMenu.setKeTextColor(PURPLE);
            buttonMenu.setKeBackgroundColor(YELLOW);
            buttonMenu.setKeTextSize(28);
          }

          if(container == containers.get(3))
          {
            PVector container2Pos = containers.get(2).getKePosition("screen");

            KElement levelsBar = _elements.get(1);
            container.addChild(levelsBar);
            levelsBar.setKePosition("screen", container2Pos.x, container2Pos.y);
            levelsBar.setKeTextColor(PURPLE);
            levelsBar.setKeBackgroundColor(YELLOW);
            levelsBar.setKeHeight(2 * container.getKeHeight());


            ArrayList<KElement> usersButtons = new ArrayList<KElement>();

            for(String username : _game.getUsers()){
              ke = new Button(BtnEvent.USER, username); 
              usersButtons.add(ke); 
              elements.add(ke);
            }
            
            int j = 0;
            for(KElement userButton : usersButtons)
            {
              Button b = (Button) userButton;
              levelsBar.addChild(b);
              b.setKeBackgroundColor(PURPLE);
              b.setKeTextColor(WHITE);
              b.setKeTextSize(28);
              b.setKeHeight(35);
              b.setKePosition("screen", levelsBar.getKePosition("screen").x , levelsBar.getKePosition("screen").y+j*b.getKeHeight());
              j++;
            }

          }
        }

        break;

      case BEST_SCORES:
        ke = new Button(BtnEvent.HOME); elements.add(ke);
        ke = new KElement();            elements.add(ke);

        _elements = elements;

        for(KElement container : containers)
        {
          if(container == containers.get(0))
          {
            Button buttonMenu = (Button) _elements.get(0);
            container.addChild(buttonMenu);
            buttonMenu.setKeTextColor(PURPLE);
            buttonMenu.setKeBackgroundColor(YELLOW);
            buttonMenu.setKeTextSize(28);
          }

          if(container == containers.get(3))
          {
            PVector container2Pos = containers.get(2).getKePosition("screen");

            KElement scoresBar = _elements.get(1);
            container.addChild(scoresBar);
            scoresBar.setKePosition("screen", container2Pos.x, container2Pos.y);
            scoresBar.setKeTextColor(PURPLE);
            scoresBar.setKeBackgroundColor(YELLOW);
            scoresBar.setKeHeight(2 * container.getKeHeight());

            int j=0;
            for(Score score : _scores.getScores()){
              String su = score.getUsername();
              String spt = " "+str(score.getPoints())+" pts ";
              String st;
              if(score.getType().equals("V")) st = "(Victoire)"; else st = "(Défaite)";

              ke = new KElement(); 
              scoresBar.addChild(ke); 
              ke.setKeBackgroundColor(PURPLE);
              ke.setKeTextColor(WHITE);
              ke.setKeTextSize(18);
              ke.setKeHeight(25);
              ke.setKeText(su+spt+st);
              ke.setKePosition("screen", scoresBar.getKePosition("screen").x , scoresBar.getKePosition("screen").y+j*ke.getKeHeight());
              j++;
            }
          }
        }
        break;

    }
  }

  private void _clearPagesElements()
  {
    for(KElement container : _template.getCellsList())
      container.removeAllChildren();
  }

  public void changePage(PageMenu page)
  { 
    _clearPagesElements();
    _page = page;
    _loadElementsIntoPage();
  }

  public BtnEvent getBtnEventOnClick()
  {
    for(KElement _button : _elements)
      if(_button instanceof Button)
      {
        Button button = (Button) _button;

        if(button.isClicked() && button.getBtnEvent() == BtnEvent.LEVEL)
          _game.changeLevelGame(button.getValue());

        if(button.isClicked() && button.getBtnEvent() == BtnEvent.USER)
          _game.selectUser(button.getValue());

        if(button.isClicked())
          return button.getBtnEvent();
        
      }
    
    return BtnEvent.DEFAULT;
  }
  
  public void drawing()
  {
    KElement[][] containers = _template.getCells();

    for(int x = 0; x < _template.getNbCol(); x++)
      for(int y = 0; y < _template.getNbRow(); y++)
      {
        KElement container = containers[x][y];
        container.drawing();
      }
  }
}

class Pawn
{   
  protected Board   _board;
  protected Cell    _cell, _nextCell;
  protected PVector _screenPos, 
                    _lastScreenPos,
                    _lastBoardPos,
                    _boardPos;
  protected int     _direction,
                    _nextDirection;
  protected float   _speed;

  Pawn(Board board)  
  {   
    _board = board;
    _lastScreenPos = new PVector(0,0);
    _lastBoardPos = new PVector(0,0);
    _direction     = LEFT;
    _nextDirection = LEFT;
    _speed = 1;
  }

  public boolean isMoveableTo(String direction)
  {
    int to;
    switch(direction)
    {
      case "currentDirection": to = _direction;     break;
      case "nextDirection":    to = _nextDirection; break;
      default: to = _direction; break;
    }

    PVector _cellPosC = _cell.getPos("center");
    int _cellPosX = PApplet.parseInt(_cell.getPos("board").x),
        _cellPosY = PApplet.parseInt(_cell.getPos("board").y);

    Cell nextCell = new Cell();
    boolean checkPositions1 = false;
    boolean checkPositions2 = false;

    switch(to)
    {
      case UP:    
        nextCell = _board.getCells()[_cellPosX][_cellPosY-1]; 
        checkPositions1 = _screenPos.x == nextCell.getPos("center").x;
        checkPositions2 = _screenPos.y == _cellPosC.y;
        break;
      case DOWN:  
        nextCell = _board.getCells()[_cellPosX][_cellPosY+1]; 
        checkPositions1 = _screenPos.x == nextCell.getPos("center").x;
        checkPositions2 = _screenPos.y == _cellPosC.y;
        break;
      case LEFT:  
        if(_cellPosX-1 == -1){ _cellPosX = _board.getNbCol(); }
        nextCell = _board.getCells()[_cellPosX-1][_cellPosY]; 
        checkPositions1 = _screenPos.y == nextCell.getPos("center").y;
        checkPositions2 = _screenPos.x == _cellPosC.x;
        break;
      case RIGHT:
        if(_cellPosX+1 == _board.getNbCol()){ _cellPosX = 0; } 
        nextCell = _board.getCells()[_cellPosX+1][_cellPosY]; 
        checkPositions1 = _screenPos.y == nextCell.getPos("center").y;
        checkPositions2 = _screenPos.x == _cellPosC.x;
        break;
      case 0: return false;
    }

    boolean isntWALL = nextCell.getType() != TypeCell.WALL && checkPositions1;
    boolean isWALL   = nextCell.getType() == TypeCell.WALL && checkPositions1 && !checkPositions2;

    return (isntWALL) || (isWALL);
  }

  public void move(int direction)
  {
    _lastScreenPos = new PVector(_screenPos.x, _screenPos.y);

    switch(direction)
    {
      case UP:    _screenPos.x = _cell.getPos("center").x ; _screenPos.y -= _speed; break;
      case DOWN:  _screenPos.x = _cell.getPos("center").x ; _screenPos.y += _speed; break;
      case LEFT:  _screenPos.y = _cell.getPos("center").y ; _screenPos.x -= _speed; break;
      case RIGHT: _screenPos.y = _cell.getPos("center").y ; _screenPos.x += _speed; break;
      case 0: break;
    }

    if(isMoving("onCellCenter") && (
      (_cell.getPos("board").x == 0 && _direction == LEFT) ||
      (_cell.getPos("board").x == _board.getNbCol()-1 && _direction == RIGHT) ) )
      _screenPos.x = _nextCell.getPos("center").x;

    _cellAssociation();
  }

  public boolean isMoving(String from)
  {
    boolean isMoving;
    switch(from)
    {
      case  "onScreen": isMoving = !(_screenPos.x == _lastScreenPos.x && _screenPos.y == _lastScreenPos.y); break;
      case "overCells": isMoving = !(_boardPos.x == _lastBoardPos.x && _boardPos.y == _lastBoardPos.y); break;
      case "onCellCenter": isMoving = !(_screenPos.x == _cell.getPos("center").x && _boardPos.y == _cell.getPos("center").y); break;
               default: isMoving = false;
    }

    return isMoving;
  }

  protected void _cellAssociation()
  {
    Cell c;
    for(int col=0; col < _board.getNbCol(); col++){
      for(int row=0; row < _board.getNbRow(); row++){
        c = _board.getCells()[col][row];
        if(c.isPointInside(_screenPos) && _cell != c)
        {
          _lastBoardPos = _cell.getPos("board");
          _cell = c;
          _nextCellAssociation(_direction);
          _boardPos = _cell.getPos("board");
          return;
        }
      }
    }
  }

  protected void _nextCellAssociation(int direction)
  {
    int ncX = PApplet.parseInt(_cell.getPos("board").x),
        ncY = PApplet.parseInt(_cell.getPos("board").y);

    Cell nextCell = new Cell();
    switch(direction)
    {
      case UP:    nextCell = _board.getCells()[ncX][ncY-1]; break;
      case DOWN:  nextCell = _board.getCells()[ncX][ncY+1]; break;
      case LEFT:  
        if(ncX-1 == -1){ ncX = _board.getNbCol(); } 
        nextCell = _board.getCells()[ncX-1][ncY]; 
        break;
      case RIGHT: 
        if(ncX+1 == _board.getNbCol()){ ncX = -1; }
        nextCell = _board.getCells()[ncX+1][ncY]; 
        break;
    }

    _nextCell = nextCell;
  }

  public void setDirection(String which, int to)
  {
    switch(which)
    {
      case "current": _direction = to;     break;
      case "next":    _nextDirection = to; break;
    }
  }

  public int getDirection(String which)
  {
    int direction = _direction;
    switch(which)
    {
      case "current": direction = _direction;     break;
      case "next":    direction = _nextDirection; break;
    }

    return direction;
  }

  public int reverseDirection()
  {
    int reverseDirection;
    switch(_direction) {
      case UP:    reverseDirection = DOWN;  break;
      case DOWN:  reverseDirection = UP;    break;
      case LEFT:  reverseDirection = RIGHT; break;
      case RIGHT: reverseDirection = LEFT;  break;
      default:    reverseDirection = 0;     break;
    }
    return reverseDirection;
  }

  public Cell getCell()
  {
    return _cell;
  }

  public void setScreenPos(float x, float y)
  {
    _screenPos.x = x;
    _screenPos.y = y;
    _cellAssociation();
  }
  public PVector getScreenPos()
  {
    return _screenPos;
  }

}
class Score
{
	private String _username;
	private String _type;
	private int _points;

	Score(String result)
	{
		String[] result_splited = split(result, "|");
		_username = result_splited[0];
		_type		  = result_splited[1];
		_points 	= PApplet.parseInt(result_splited[2]);
	}

	public String getUsername()
	{
		return _username;
	}

	public String getType()
	{
		return _type;
	}

	public int getPoints()
	{
		return _points;
	}
}

class Scores
{
	private String _file;
	private ArrayList<Score> _scores;

	Scores()
	{
		_scores = new ArrayList<Score>();
		_updateScores();
	}

	private void _updateScores()
	{
		String[] strings = loadStrings("data/scores/scores.txt");
		_file = strings[0];
		String[] scores = split(_file,";");

		for(int i=0; i < scores.length; i++)
			_scores.add(new Score(scores[i]));

		Collections.sort(_scores, new Comparator<Score>(){
			public int compare(Score s1, Score s2) 
			{
	  		int scorepoints1 = s1.getPoints();
	  		int scorepoints2 = s2.getPoints();
	  		return scorepoints2-scorepoints1;
  		}
		});
	}

	public void addScore(String newScore)
	{
		String[] strings = {newScore};
		saveStrings("data/scores/scores.txt", strings);

		_updateScores();
	}

	public ArrayList<Score> getScoresAbout(String about)
	{
		ArrayList<Score> scoresBy = new ArrayList<Score>();

		for(Score _score : _scores){
			switch(about){
				case "victories": if(_score.getType().equals("V")) scoresBy.add(_score); break;
				case "losses": 		if(_score.getType().equals("D")) scoresBy.add(_score); break;
			}
		}
		return scoresBy;
	}

	public ArrayList<Score> getScores()
	{
		return _scores;
	}
}


  public void settings() { size(800, 800, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "pacman" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
